<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MapReduce Data Flow</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div id="container">
        <nav class="top-nav">
            <a href="../../index.html" class="back-link">â† Back to Home</a>
            <button id="theme-toggle" class="theme-toggle" aria-label="Toggle theme">
                <span class="theme-icon">ğŸŒ™</span>
            </button>
        </nav>
        <h1>MapReduce Data Flow Visualization</h1>
        
        <div id="controls">
            <div class="control-group">
                <h3>Job Control</h3>
                <div class="controls-row">
                    <button id="start-btn" class="primary-button">Start Job</button>
                    <button id="map-btn" class="step-button" disabled>Execute Map Phase</button>
                    <button id="shuffle-btn" class="step-button" disabled>Execute Shuffle Phase</button>
                    <button id="reduce-btn" class="step-button" disabled>Execute Reduce Phase</button>
                    <button id="reset-btn" class="reset-button">Reset</button>
                </div>
                <div class="job-status">
                    <div class="status-item">
                        <span class="label">Status:</span>
                        <span id="job-status" class="value">Idle</span>
                    </div>
                    <div class="status-item">
                        <span class="label">Stage:</span>
                        <span id="current-stage" class="value">Ready to start</span>
                    </div>
                    <div class="status-item">
                        <span class="label">Progress:</span>
                        <span id="progress" class="value">0%</span>
                    </div>
                </div>
                <div class="progress-bar">
                    <div id="progress-fill" class="progress-fill"></div>
                </div>
            </div>
        </div>

        <div class="main-content">
            <div class="visualization-container">
                <!-- Input Data -->
                <div class="stage-section" id="input-section">
                    <h2>ğŸ“¥ Input Data</h2>
                    <div id="input-data" class="data-container"></div>
                </div>

                <!-- Map Phase -->
                <div class="stage-section" id="map-section">
                    <h2>ğŸ—ºï¸ Map Phase (Parallel)</h2>
                    <div class="workers-container" id="map-workers"></div>
                </div>

                <!-- Shuffle & Sort Phase -->
                <div class="stage-section" id="shuffle-section">
                    <h2>ğŸ”€ Shuffle & Sort Phase</h2>
                    <div id="shuffle-data" class="data-container"></div>
                </div>

                <!-- Reduce Phase -->
                <div class="stage-section" id="reduce-section">
                    <h2>ğŸ“Š Reduce Phase (Parallel)</h2>
                    <div class="workers-container" id="reduce-workers"></div>
                </div>

                <!-- Final Output -->
                <div class="stage-section" id="output-section">
                    <h2>âœ… Final Output</h2>
                    <div id="final-output" class="data-container"></div>
                </div>
            </div>
        </div>

        <!-- Explanation Panel (Moved to bottom for better readability) -->
        <div id="explanation-panel">
            <h2>Understanding MapReduce</h2>
                <div class="explanation-content">
                    <h3>What is MapReduce? ğŸŒ</h3>
                    <p>MapReduce is a programming model for processing large datasets in parallel across distributed clusters. It divides work into independent tasks that can run simultaneously on multiple machines.</p>

                    <h3>The Three Main Phases:</h3>
                    
                    <h4>1. Map Phase ğŸ—ºï¸</h4>
                    <ul>
                        <li><strong>Input:</strong> Raw data split into chunks</li>
                        <li><strong>Process:</strong> Each mapper processes its chunk independently</li>
                        <li><strong>Output:</strong> Key-value pairs (e.g., word â†’ 1)</li>
                        <li><strong>Parallelism:</strong> Multiple mappers run simultaneously</li>
                    </ul>

                    <h4>2. Shuffle & Sort Phase ğŸ”€</h4>
                    <ul>
                        <li><strong>Partitioning:</strong> Group all values by key</li>
                        <li><strong>Sorting:</strong> Sort keys alphabetically</li>
                        <li><strong>Distribution:</strong> Send each key to a specific reducer</li>
                        <li><strong>Purpose:</strong> Prepare data for aggregation</li>
                    </ul>

                    <h4>3. Reduce Phase ğŸ“Š</h4>
                    <ul>
                        <li><strong>Input:</strong> All values for a specific key</li>
                        <li><strong>Process:</strong> Aggregate/combine values</li>
                        <li><strong>Output:</strong> Final result per key</li>
                        <li><strong>Parallelism:</strong> Multiple reducers run simultaneously</li>
                    </ul>

                    <h3>Example: Word Count</h3>
                    <div class="example-box">
                        <p><strong>Input:</strong> "hello world hello"</p>
                        <p><strong>Map Output:</strong> (hello, 1), (world, 1), (hello, 1)</p>
                        <p><strong>Shuffle:</strong> hello â†’ [1, 1], world â†’ [1]</p>
                        <p><strong>Reduce Output:</strong> (hello, 2), (world, 1)</p>
                    </div>

                    <h3>Key Benefits:</h3>
                    <ul>
                        <li><strong>Scalability:</strong> Add more machines = faster processing</li>
                        <li><strong>Fault Tolerance:</strong> Failed tasks automatically restart</li>
                        <li><strong>Simplicity:</strong> Developers only write map() and reduce()</li>
                        <li><strong>Data Locality:</strong> Process data where it's stored</li>
                    </ul>

                    <h3>Real-World Uses:</h3>
                    <ul>
                        <li><strong>Google:</strong> Web indexing, PageRank calculation</li>
                        <li><strong>Facebook:</strong> Log analysis, data warehousing</li>
                        <li><strong>Netflix:</strong> Recommendation algorithms</li>
                        <li><strong>Twitter:</strong> Trend analysis, user analytics</li>
                    </ul>

                    <h3>Try It:</h3>
                    <ol>
                        <li>Click "Start Job" to initialize</li>
                        <li>Click "Execute Map Phase" to see parallel mapping</li>
                        <li>Click "Execute Shuffle Phase" to see data partitioning</li>
                        <li>Click "Execute Reduce Phase" to see final aggregation</li>
                    </ol>

                    <h3>ğŸ”§ Backend Simulation Architecture</h3>
                    <div class="backend-section">
                        <h4>MapReduce Data Flow</h4>
                        
                        <div class="architecture-diagram">
                            <pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    MAPREDUCE ARCHITECTURE                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

INPUT DATA: "the quick brown fox the lazy dog"

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ MAP PHASE (Parallel Processing on 2 Machines)                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    Machine 1: "the quick brown fox"
        map("the quick brown fox")
        â†’ [("the",1), ("quick",1), ("brown",1), ("fox",1)]
    
    Machine 2: "the lazy dog"
        map("the lazy dog")
        â†’ [("the",1), ("lazy",1), ("dog",1)]

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SHUFFLE PHASE (Group by Key â†’ Partition â†’ Sort)              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    Partition 0 (hash("quick") % 2 = 0):
        "quick" â†’ [1]
    
    Partition 1 (hash("the") % 2 = 1):
        "the" â†’ [1, 1]
        "brown" â†’ [1]
        "fox" â†’ [1]
        "lazy" â†’ [1]
        "dog" â†’ [1]

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ REDUCE PHASE (Parallel Aggregation on 2 Machines)            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    Reducer 0:
        reduce("quick", [1]) â†’ ("quick", 1)
    
    Reducer 1:
        reduce("the", [1,1]) â†’ ("the", 2)
        reduce("brown", [1]) â†’ ("brown", 1)
        reduce("fox", [1]) â†’ ("fox", 1)
        reduce("lazy", [1]) â†’ ("lazy", 1)
        reduce("dog", [1]) â†’ ("dog", 1)

FINAL OUTPUT: {"the":2, "quick":1, "brown":1, "fox":1, "lazy":1, "dog":1}</code></pre>
                        </div>

                        <div class="algorithm-impl">
                            <h5>1ï¸âƒ£ Map Phase</h5>
                            <pre><code>FUNCTION Map(text):
    // Split text into words
    words = text.split(" ")
    pairs = []
    
    // Emit (word, 1) for each word
    FOR EACH word IN words:
        pairs.append((word, 1))
    END FOR
    
    RETURN pairs
END FUNCTION

EXAMPLE:
    Input: "the quick brown"
    Output: [("the", 1), ("quick", 1), ("brown", 1)]

KEY INSIGHT: Maps run IN PARALLEL on different machines
    - Each mapper processes a chunk of input
    - No communication between mappers needed
    - Linear scalability: 2x machines â†’ 2x throughput</code></pre>
                        </div>

                        <div class="algorithm-impl">
                            <h5>2ï¸âƒ£ Shuffle Phase (Partition â†’ Sort â†’ Copy)</h5>
                            <pre><code>FUNCTION Shuffle(allMapOutputs, numReducers):
    partitions = createArray(numReducers)
    
    // STEP 1: Partition by key hash
    FOR EACH (key, value) IN allMapOutputs:
        partitionID = hash(key) MOD numReducers
        partitions[partitionID].append((key, value))
    END FOR
    
    // STEP 2: Sort each partition by key
    FOR EACH partition IN partitions:
        partition.sort(byKey)
    END FOR
    
    // STEP 3: Group values by key
    groupedPartitions = []
    FOR EACH partition IN partitions:
        grouped = groupByKey(partition)
        groupedPartitions.append(grouped)
    END FOR
    
    RETURN groupedPartitions
END FUNCTION

FUNCTION groupByKey(sortedPairs):
    grouped = Map()
    FOR EACH (key, value) IN sortedPairs:
        IF key NOT IN grouped THEN
            grouped[key] = []
        END IF
        grouped[key].append(value)
    END FOR
    RETURN grouped
END FUNCTION

EXAMPLE:
    Input: [("the",1), ("fox",1), ("the",1), ("dog",1)]
    After Partition (2 reducers):
        Partition 0: [("fox",1), ("dog",1)]
        Partition 1: [("the",1), ("the",1)]
    After Sort & Group:
        Partition 0: {fox: [1], dog: [1]}
        Partition 1: {the: [1, 1]}

KEY INSIGHT: Shuffle is the MOST EXPENSIVE phase
    - Network transfer between mappers and reducers
    - All-to-all communication pattern
    - Sorting for grouping efficiency</code></pre>
                        </div>

                        <div class="algorithm-impl">
                            <h5>3ï¸âƒ£ Reduce Phase</h5>
                            <pre><code>FUNCTION Reduce(key, values):
    // Aggregate all values for this key
    sum = 0
    FOR EACH value IN values:
        sum = sum + value
    END FOR
    
    RETURN (key, sum)
END FUNCTION

EXAMPLE:
    Input: ("the", [1, 1])
    Output: ("the", 2)

KEY INSIGHT: Reducers run IN PARALLEL on different machines
    - Each reducer processes a subset of keys
    - No communication between reducers needed
    - Output is final result for that partition</code></pre>
                        </div>

                        <h4>ğŸ¯ Why MapReduce?</h4>
                        <table class="comparison-table">
                            <thead>
                                <tr>
                                    <th>Challenge</th>
                                    <th>Traditional Approach</th>
                                    <th>MapReduce Solution</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Process 1TB of data</td>
                                    <td>Single machine â†’ 10+ hours</td>
                                    <td>1000 machines â†’ 1 minute!</td>
                                </tr>
                                <tr>
                                    <td>Machine failures</td>
                                    <td>Start over from scratch</td>
                                    <td>Automatic retry of failed tasks</td>
                                </tr>
                                <tr>
                                    <td>Data distribution</td>
                                    <td>Manual partitioning & copying</td>
                                    <td>Automatic shuffle & sort</td>
                                </tr>
                                <tr>
                                    <td>Code complexity</td>
                                    <td>Handle parallelism, networking, failures</td>
                                    <td>Write simple map() and reduce() functions</td>
                                </tr>
                            </tbody>
                        </table>

                        <h4>ğŸ“Š Real-World Performance</h4>
                        <p><strong>Google's original MapReduce (2004):</strong></p>
                        <ul>
                            <li>Sort 10 billion 100-byte records (1TB) on 1800 machines in <strong>6 minutes</strong></li>
                            <li>Grep 10TB of data on 1800 machines in <strong>2.5 minutes</strong></li>
                        </ul>

                    </div>
                </div>
            </div>
        </div>
    </div>
    <script src="../../session.js"></script>
    <script src="../../theme.js"></script>
    <script src="app.js" defer></script>
</body>
</html>

