<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rate Limiting Algorithms Simulator</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div id="container">
        <nav class="top-nav">
            <a href="../../index.html" class="back-link">‚Üê Back to Home</a>
            <button id="theme-toggle" class="theme-toggle" aria-label="Toggle theme">
                <span class="theme-icon">üåô</span>
            </button>
        </nav>
        
        <h1>Rate Limiting Algorithms Simulator</h1>
        <p class="subtitle">Compare 5 different rate limiting algorithms: Limit = 10 requests per 60 seconds</p>
        
        <div id="controls">
            <div class="control-group">
                <h3>Controls</h3>
                <div class="controls-row">
                    <button id="send-request-btn" class="primary-button">Send 1 Request</button>
                    <button id="send-burst-btn" class="burst-button">Send 10 Requests (Burst)</button>
                    <button id="reset-btn" class="reset-button">Reset All</button>
                </div>
                <div id="request-feedback"></div>
            </div>
        </div>
        
        <div id="algorithms-container">
            <div class="algorithm-card" id="fixed-window">
                <h3>Fixed Window Counter</h3>
                <div class="algorithm-visual">
                    <div class="counter-display">
                        <span class="count-label">Count:</span>
                        <span class="count-value" id="fw-count">0</span>
                        <span class="count-limit">/ 10</span>
                    </div>
                    <div class="window-indicator">
                        <div class="window-bar" id="fw-bar"></div>
                        <span class="window-label">Window Progress</span>
                    </div>
                </div>
                <div class="request-history" id="fw-history"></div>
                <div class="algorithm-info">
                    <p><strong>Simple Concept:</strong> Like a timer that resets every 60 seconds</p>
                    <p><strong>Example:</strong> "You can make 10 calls per minute"</p>
                    <p><strong>Problem:</strong> 10 calls at 11:59:59 + 10 calls at 12:00:01 = 20 calls in 2 seconds! ‚ö†Ô∏è</p>
                </div>
            </div>
            
            <div class="algorithm-card" id="sliding-log">
                <h3>Sliding Log</h3>
                <div class="algorithm-visual">
                    <div class="counter-display">
                        <span class="count-label">Count:</span>
                        <span class="count-value" id="sl-count">0</span>
                        <span class="count-limit">/ 10</span>
                    </div>
                    <div class="log-display-enhanced" id="sl-log-enhanced">
                        <div class="log-timeline">
                            <div class="timeline-bar"></div>
                            <div class="timeline-labels">
                                <span>Now</span>
                                <span>-60s</span>
                            </div>
                            <div class="log-entries-timeline" id="sl-timeline-entries"></div>
                        </div>
                    </div>
                </div>
                <div class="request-history" id="sl-history"></div>
                <div class="algorithm-info">
                    <p><strong>Simple Concept:</strong> Writes down exact time of each request</p>
                    <p><strong>Example:</strong> "Show me all requests in last 60 seconds" - counts them</p>
                    <p><strong>Trade-off:</strong> Most accurate but uses more memory üìù</p>
                </div>
            </div>
            
            <div class="algorithm-card" id="sliding-window">
                <h3>Sliding Window Counter</h3>
                <div class="algorithm-visual">
                    <div class="counter-display">
                        <span class="count-label">Estimated:</span>
                        <span class="count-value" id="sw-count">0</span>
                        <span class="count-limit">/ 10</span>
                    </div>
                    <div class="window-indicator">
                        <div class="dual-window">
                            <div class="prev-window" id="sw-prev">
                                <span>Prev: <span id="sw-prev-count">0</span></span>
                            </div>
                            <div class="curr-window" id="sw-curr">
                                <span>Curr: <span id="sw-curr-count">0</span></span>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="request-history" id="sw-history"></div>
                <div class="algorithm-info">
                    <p><strong>Simple Concept:</strong> Looks at current minute + part of previous minute</p>
                    <p><strong>Example:</strong> At 30 seconds, counts: 50% of prev minute + 100% of current</p>
                    <p><strong>Sweet Spot:</strong> Accurate enough + low memory = Production favorite! ‚≠ê</p>
                </div>
            </div>
            
            <div class="algorithm-card" id="token-bucket">
                <h3>Token Bucket</h3>
                <div class="algorithm-visual">
                    <div class="counter-display">
                        <span class="count-label">Tokens:</span>
                        <span class="count-value" id="tb-tokens">10</span>
                        <span class="count-limit">/ 10</span>
                    </div>
                    <div class="bucket-display">
                        <div class="bucket">
                            <div class="bucket-fill" id="tb-fill"></div>
                            <div class="bucket-label">Token Bucket</div>
                        </div>
                        <div class="refill-info">
                            <span>Refill: 0.17/sec</span>
                        </div>
                    </div>
                </div>
                <div class="request-history" id="tb-history"></div>
                <div class="algorithm-info">
                    <p><strong>Simple Concept:</strong> Like a piggy bank that slowly fills with coins</p>
                    <p><strong>Example:</strong> Start with 10 tokens. Use 1 per request. Gain 1 every 6 seconds</p>
                    <p><strong>Cool Feature:</strong> Save up tokens for a burst! (Great for APIs) ü™ô</p>
                </div>
            </div>
            
            <div class="algorithm-card" id="leaky-bucket">
                <h3>Leaky Bucket</h3>
                <div class="algorithm-visual">
                    <div class="counter-display">
                        <span class="count-label">Queue:</span>
                        <span class="count-value" id="lb-queue">0</span>
                        <span class="count-limit">/ 10</span>
                    </div>
                    <div class="bucket-display">
                        <div class="bucket leaky">
                            <div class="bucket-fill" id="lb-fill"></div>
                            <div class="bucket-label">Request Queue</div>
                            <div class="leak-indicator">üíß</div>
                        </div>
                        <div class="refill-info">
                            <span>Process: 0.17/sec</span>
                        </div>
                    </div>
                </div>
                <div class="request-history" id="lb-history"></div>
                <div class="algorithm-info">
                    <p><strong>Simple Concept:</strong> Like a water bucket with a tiny hole at bottom</p>
                    <p><strong>Example:</strong> Requests fill bucket. They "leak out" at steady rate (0.17/sec)</p>
                    <p><strong>Cool Feature:</strong> Perfect for smooth streaming! Overflow = rejected üíß</p>
                </div>
            </div>
        </div>
        
        <div id="explanation-panel">
            <h2>Understanding Rate Limiting</h2>
            <div class="explanation-content">
                <h3>What is Rate Limiting?</h3>
                <p><strong>Real-Life Example:</strong> Imagine a coffee shop that says "maximum 10 cups per person per hour"</p>
                <p>Rate limiting is the same but for servers: <em>"You can make maximum 10 requests per 60 seconds"</em></p>
                <p><strong>Why?</strong> Prevents abuse, ensures fair access, protects servers from overload</p>
                
                <h3>Quick Comparison</h3>
                <table class="comparison-table">
                    <thead>
                        <tr>
                            <th>Algorithm</th>
                            <th>Simple Analogy</th>
                            <th>Best For</th>
                            <th>Problem</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Fixed Window</strong></td>
                            <td>‚è∞ Timer that resets every minute</td>
                            <td>Simple apps</td>
                            <td>Can get 2x limit at reset time</td>
                        </tr>
                        <tr>
                            <td><strong>Sliding Log</strong></td>
                            <td>üìù Write down every request time</td>
                            <td>When accuracy is critical</td>
                            <td>Uses lots of memory</td>
                        </tr>
                        <tr>
                            <td><strong>Sliding Window</strong></td>
                            <td>üìä Smart average of 2 windows</td>
                            <td>Most production apps ‚≠ê</td>
                            <td>Slightly approximate</td>
                        </tr>
                        <tr>
                            <td><strong>Token Bucket</strong></td>
                            <td>ü™ô Piggy bank that refills</td>
                            <td>APIs (allows bursts)</td>
                            <td>Can drain fully in burst</td>
                        </tr>
                        <tr>
                            <td><strong>Leaky Bucket</strong></td>
                            <td>üíß Water bucket with hole</td>
                            <td>Video streaming (smooth)</td>
                            <td>Bursts must wait in queue</td>
                        </tr>
                    </tbody>
                </table>
                
                <h3>Real-World Usage Examples</h3>
                <ul>
                    <li><strong>Fixed Window:</strong> Internal tools, simple rate limits (easiest to implement)</li>
                    <li><strong>Sliding Log:</strong> Banking APIs, security systems (needs perfect accuracy)</li>
                    <li><strong>Sliding Window:</strong> Twitter, Facebook, most REST APIs (best overall balance) ‚≠ê</li>
                    <li><strong>Token Bucket:</strong> AWS API Gateway, GitHub API (allows burst for good users)</li>
                    <li><strong>Leaky Bucket:</strong> Netflix streaming, video processing (needs smooth rate)</li>
                </ul>
                
                <h3>Key Insight: The Burst Problem</h3>
                <p><strong>Fixed Window issue:</strong> User makes 10 requests at 11:59:59, then 10 more at 12:00:01 ‚Üí 20 requests in 2 seconds!</p>
                <p><strong>Sliding Window fix:</strong> Counts across window boundaries, so burst is detected</p>
                <p><strong>Token Bucket difference:</strong> <em>Intentionally</em> allows bursts (good for APIs that spike sometimes)</p>
                
                <h3>Try It Yourself!</h3>
                <ol>
                    <li>Click "Send 1 Request" multiple times - see how each algorithm handles it</li>
                    <li>Click "Send 10 Requests" - see burst behavior differences</li>
                    <li>Wait 60 seconds and try again - observe reset/refill behavior</li>
                </ol>

                <h3>üîß Real-World Rate Limiting Implementations</h3>
                <div class="backend-section">
                    <h4>How Production Systems Implement Rate Limiting</h4>
                    <p>Real-world implementations using Redis, Nginx, and distributed systems:</p>
                    
                    <div class="algorithm-impl">
                        <h5>1Ô∏è‚É£ Fixed Window Counter (Redis - GitHub/Stripe)</h5>
                        <pre><code>// Redis Implementation (most common for APIs)
FUNCTION AllowRequest(userID, limit=10, windowSize=60):
    now = getCurrentTime()
    windowStart = FLOOR(now / windowSize) * windowSize
    
    // Redis key includes user and time window
    key = "rate_limit:" + userID + ":" + windowStart
    
    // INCR is atomic - safe for distributed systems!
    count = REDIS.INCR(key)
    
    // Set TTL on first request (auto-cleanup)
    IF count == 1 THEN
        REDIS.EXPIRE(key, windowSize)
    END IF
    
    allowed = (count <= limit)
    RETURN {
        allowed: allowed,
        remaining: MAX(0, limit - count),
        resetAt: windowStart + windowSize
    }
END FUNCTION

Time Complexity: O(1) - single Redis operation
Space: O(users √ó windows) - but auto-expires!

REDIS EXAMPLE:
    > INCR rate_limit:user123:1702891200
    (integer) 1
    > EXPIRE rate_limit:user123:1702891200 60
    OK
    > GET rate_limit:user123:1702891200
    "1"

KEY INSIGHTS:
    ‚úÖ Distributed: Multiple servers share Redis
    ‚úÖ Atomic: INCR prevents race conditions
    ‚úÖ Memory: Auto-expires old windows
    ‚ö†Ô∏è Burst: 20 req at X:59 + 10 at Y:00 = 30 total</code></pre>
                        <p><strong>Used by:</strong> GitHub API (5000 req/hr), Stripe API, Shopify, Twitter API</p>
                    </div>

                    <div class="algorithm-impl">
                        <h5>2Ô∏è‚É£ Sliding Log (Redis Sorted Set - Cloudflare)</h5>
                        <pre><code>// Redis Sorted Sets for precise rate limiting
FUNCTION AllowRequest(userID, limit=10, windowSize=60):
    now = getCurrentTime()
    cutoff = now - windowSize
    key = "rate_limit:log:" + userID
    
    // Step 1: Remove old entries (outside window)
    REDIS.ZREMRANGEBYSCORE(key, 0, cutoff)
    
    // Step 2: Count requests in window
    count = REDIS.ZCARD(key)
    
    IF count < limit THEN
        // Step 3: Add current request with timestamp as score
        REDIS.ZADD(key, now, generateUUID())
        REDIS.EXPIRE(key, windowSize)  // Auto-cleanup
        RETURN {allowed: true, remaining: limit - count - 1}
    ELSE
        RETURN {allowed: false, remaining: 0}
    END IF
END FUNCTION

Time Complexity: O(log N) for ZADD, O(log N + M) for ZREMRANGEBYSCORE
Space: O(limit √ó users) - stores all request timestamps

REDIS EXAMPLE:
    > ZREMRANGEBYSCORE rate_limit:log:user123 0 1702891140
    (integer) 3
    > ZCARD rate_limit:log:user123
    (integer) 7
    > ZADD rate_limit:log:user123 1702891200 "req-uuid-123"
    (integer) 1

KEY INSIGHTS:
    ‚úÖ Perfect accuracy - no bursts at boundaries
    ‚úÖ Distributed across Redis cluster
    ‚ö†Ô∏è Memory: Stores every request ID
    ‚ö†Ô∏è Cleanup: Must remove old entries on each check</code></pre>
                        <p><strong>Used by:</strong> Cloudflare (DDoS protection), Financial APIs (strict compliance)</p>
                    </div>

                    <div class="algorithm-impl">
                        <h5>3Ô∏è‚É£ Sliding Window Counter</h5>
                        <pre><code>ALGORITHM SlidingWindowCounter:
    STATE:
        limit = 10
        windowSize = 60 seconds
        currentCount = 0      // Requests in current window
        previousCount = 0     // Requests in previous window
        currentStart = <current_time>
    
    FUNCTION AllowRequest():
        now = getCurrentTime()
        elapsed = now - currentStart
        
        // Slide window forward if needed
        IF elapsed >= windowSize THEN
            previousCount = currentCount
            currentCount = 0
            currentStart = now
        END IF
        
        // Calculate weighted estimate
        previousWeight = 1.0 - (elapsed / windowSize)
        estimatedCount = (previousCount * previousWeight) + currentCount
        
        IF estimatedCount < limit THEN
            currentCount = currentCount + 1
            RETURN true
        END IF
        
        RETURN false
    END FUNCTION
    
Time Complexity: O(1)
Space Complexity: O(1)</code></pre>
                        <p><strong>Key Point:</strong> Hybrid approach. Uses two counters and weighted calculation. Smooth approximation with O(1) memory.</p>
                    </div>

                    <div class="algorithm-impl">
                        <h5>4Ô∏è‚É£ Token Bucket</h5>
                        <pre><code>ALGORITHM TokenBucket:
    STATE:
        capacity = 10          // Max tokens
        tokens = 10.0          // Current tokens
        refillRate = 0.167     // Tokens per second (10/60)
        lastRefill = <current_time>
    
    FUNCTION AllowRequest():
        now = getCurrentTime()
        elapsed = (now - lastRefill) in seconds
        
        // Refill tokens based on time passed
        tokensToAdd = elapsed * refillRate
        tokens = MIN(tokens + tokensToAdd, capacity)
        lastRefill = now
        
        // Consume one token if available
        IF tokens >= 1.0 THEN
            tokens = tokens - 1.0
            RETURN true
        END IF
        
        RETURN false
    END FUNCTION
    
    // Background process (runs every second)
    FUNCTION RefillTokens():
        WHILE true DO
            SLEEP(1 second)
            elapsed = 1.0
            tokensToAdd = elapsed * refillRate
            tokens = MIN(tokens + tokensToAdd, capacity)
        END WHILE
    END FUNCTION
    
Time Complexity: O(1)
Space Complexity: O(1)</code></pre>
                        <p><strong>Key Point:</strong> Tokens refill continuously. Allows bursts (use accumulated tokens) but rate-limited over time. O(1) with background refill.</p>
                    </div>

                    <div class="algorithm-impl">
                        <h5>5Ô∏è‚É£ Leaky Bucket</h5>
                        <pre><code>ALGORITHM LeakyBucket:
    STATE:
        capacity = 10          // Max queue size
        leakRate = 0.167       // Process rate per second
        queue = []             // Request queue
        lastLeak = <current_time>
    
    FUNCTION AllowRequest():
        now = getCurrentTime()
        elapsed = (now - lastLeak) in seconds
        
        // "Leak" (process) requests at constant rate
        requestsToLeak = FLOOR(elapsed * leakRate)
        
        IF requestsToLeak > 0 THEN
            IF requestsToLeak >= length(queue) THEN
                queue = []  // Empty the queue
            ELSE
                queue = queue[requestsToLeak:]  // Remove first N items
            END IF
            lastLeak = now
        END IF
        
        // Add request to queue if space available
        IF length(queue) < capacity THEN
            queue.append(now)
            RETURN true
        END IF
        
        RETURN false  // Queue is full
    END FUNCTION
    
    // Background process (runs every second)
    FUNCTION ProcessQueue():
        WHILE true DO
            SLEEP(1 second)
            requestsToLeak = FLOOR(leakRate)
            IF length(queue) > 0 THEN
                queue = queue[requestsToLeak:]
            END IF
        END WHILE
    END FUNCTION
    
Time Complexity: O(1) for add, O(n) for cleanup
Space Complexity: O(n) where n = queue size</code></pre>
                        <p><strong>Key Point:</strong> Requests fill a queue that "leaks" at constant rate. Smooths bursts into steady output. FIFO queue with O(n) memory.</p>
                    </div>

                    <h4>üéØ Key Takeaways</h4>
                    <table class="comparison-table">
                        <thead>
                            <tr>
                                <th>Algorithm</th>
                                <th>Memory</th>
                                <th>Accuracy</th>
                                <th>Burst Handling</th>
                                <th>Use Case</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Fixed Window</td>
                                <td>O(1)</td>
                                <td>Low</td>
                                <td>Poor (edge bursts)</td>
                                <td>Simple APIs, low traffic</td>
                            </tr>
                            <tr>
                                <td>Sliding Log</td>
                                <td>O(n)</td>
                                <td>Perfect</td>
                                <td>Excellent</td>
                                <td>Critical systems, compliance</td>
                            </tr>
                            <tr>
                                <td>Sliding Window</td>
                                <td>O(1)</td>
                                <td>High</td>
                                <td>Good</td>
                                <td>Production (best balance)</td>
                            </tr>
                            <tr>
                                <td>Token Bucket</td>
                                <td>O(1)</td>
                                <td>High</td>
                                <td>Allows bursts</td>
                                <td>APIs with traffic spikes</td>
                            </tr>
                            <tr>
                                <td>Leaky Bucket</td>
                                <td>O(n)</td>
                                <td>High</td>
                                <td>Smooths bursts</td>
                                <td>Network routers, QoS</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>
    <script src="../../session.js"></script>
    <script src="app.js" defer></script>
</body>
</html>

